# 2025 - 11 - 16 
-- Example Table: employees
| emp_id | emp_name | manager_id | department |
| ------ | -------- | ---------- | ---------- |
| 1      | Alice    | NULL       | HR         |
| 2      | Bob      | 1          | HR         |
| 3      | Charlie  | 1          | HR         |
| 4      | David    | 2          | IT         |
| 5      | Emma     | 2          | IT         |
| 6      | Frank    | 3          | Sales      |


1. Basic Self Join ‚Äì Find Employees and Their Managers
SELECT 
  e.emp_name AS Employee,
  m.emp_name AS Manager
FROM employees e
JOIN employees m 
  ON e.manager_id = m.emp_id;

2. Find employees and managers in the same department:
SELECT 
  e.emp_name AS Employee,
  m.emp_name AS Manager,
  e.department
FROM employees e
JOIN employees m 
  ON e.manager_id = m.emp_id
WHERE e.department = m.department;

3. Find Employees Who Don‚Äôt Have a Manager
SELECT 
  e.emp_name
FROM employees e
LEFT JOIN employees m 
  ON e.manager_id = m.emp_id
WHERE m.emp_id IS NULL;

4. Show Manager‚ÄìEmployee Hierarchy (with IDs)
SELECT 
  e.emp_id AS Employee_ID,
  e.emp_name AS Employee,
  m.emp_id AS Manager_ID,
  m.emp_name AS Manager
FROM employees e
LEFT JOIN employees m 
  ON e.manager_id = m.emp_id;

# üß† Practice Ideas:

Try writing these yourself:

1. List all employees who have the same manager.

2. Find employees whose manager‚Äôs name starts with ‚ÄúA‚Äù.

3. Show how many employees each manager handles (hint: use GROUP BY m.emp_name).

CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    department VARCHAR(30),
    salary INT,
    hire_date DATE,
    email VARCHAR(50),
    manager_id INT
);

INSERT INTO employees VALUES
(1, 'Amit Sharma', 'IT',      75000, '2020-01-15', 'amit.sharma@company.com', NULL),
(2, 'Riya Verma',  'HR',      60000, '2019-07-10', 'riya.v@company.com',       1),
(3, 'Mohit Gupta', 'IT',      82000, '2021-03-20', 'mohit.g@company.com',      1),
(4, 'Sneha Rao',   'Finance', 90000, '2018-11-05', 'sneha.rao@company.com',    NULL),
(5, 'Arjun Mehta', 'HR',      58000, '2022-09-12', 'arjun@company.com',        2),
(6, 'Neha Singh',  'IT',      79000, '2023-02-25', 'neha.s@company.com',       3),
(7, 'Vivek Patel', 'Finance', 65000, '2019-05-30', 'vivek_patel@company.com',  4);

Q1. Get first name and last name separately from emp_name. (Hint: SUBSTRING, LOCATE, LEFT, RIGHT)
Q2. Extract only the domain (company.com) from email. (Hint: SUBSTRING_INDEX or RIGHT)
Q3. Convert all employee names to uppercase. (Hint: UPPER())
Q4. Show only employees where email starts with the first name. (Hint: LIKE + LOWER(emp_name) manipulation)
Q5. Replace spaces in names with underscores. (Hint: REPLACE())
Q6. Find employees whose names contain exactly 2 words. (Hint: count spaces ‚Üí LENGTH(emp_name) - LENGTH(REPLACE(emp_name,' ','')))
Q7. Show name length and email length.
Q8. Show employees hired in the last 2 years. (Hint: DATEDIFF, INTERVAL)
Q9. Display hire_date and the day name (Monday, Tuesday...). (Hint: DAYNAME()) and date_formate(col_name,"%W , %a")
Q10. Extract only the month and year from hire_date. (Hint: MONTH(), YEAR())
Q11. Find employees with weekend joining dates. (Hint: DAYOFWEEK() , weekday())
Q12. Calculate how many days each employee has worked. (Hint: DATEDIFF(CURDATE(), hire_date))
Q13. Show employees hired between 2020 and 2023. (Hint: BETWEEN + date)
Q14. Find employees who earn more than the average salary. (Hint: subquery for AVG)
Q15. Find the employee with the second-highest salary. (Hint: subquery + MAX())
Q16. List employees working under the same manager. (Hint: subquery using manager_id)
Q17. Show employees whose salary is above the HR department average. (Hint: correlated subquery)
Q18. Find employees who were hired after Amit Sharma. (Hint: subquery on hire_date)
Q19. Show departments with more than 1 employee. (Hint: subquery with GROUP BY)
Q20. Use CTE to show employees with their manager‚Äôs name. (Hint: self join inside CTE)
Q21. CTE to calculate total salary per department. (Hint: GROUP BY inside CTE)
Q22. CTE to find top 3 highest-salaried employees. (Hint: ROW_NUMBER() inside CTE)
Q23. Recursive CTE: find full reporting chain (employee ‚Üí manager). (Hint: recursive CTE, if allowed)
Q24. CTE to show employees hired before the earliest hire date in IT. (Hint: use min(hire_date) in CTE)
Q25. CTE + subquery: find employees earning above company median salary.


# Window Function Practice Questions

CREATE TABLE sales_data (
    id INT,
    order_date DATE,
    region VARCHAR(20),
    category VARCHAR(20),
    sub_category VARCHAR(30),
    sales DECIMAL(10,2),
    quantity INT,
    profit DECIMAL(10,2)
);

INSERT INTO sales_data VALUES
(1, '2020-01-01', 'East', 'Furniture', 'Chairs', 200, 2, 40),
(2, '2020-01-03', 'East', 'Furniture', 'Tables', 450, 3, 90),
(3, '2020-01-05', 'West', 'Office', 'Binders', 90, 4, 10),
(4, '2020-01-07', 'South', 'Office', 'Paper', 30, 2, 5),
(5, '2020-01-10', 'West', 'Technology', 'Phones', 900, 1, 120),
(6, '2020-01-12', 'East', 'Technology', 'Accessories', 150, 2, 25),
(7, '2020-01-15', 'South', 'Furniture', 'Chairs', 300, 3, 50),
(8, '2020-01-18', 'North', 'Office', 'Binders', 120, 4, 15),
(9, '2020-01-20', 'North', 'Technology', 'Phones', 1100, 1, 180),
(10,'2020-01-25', 'East', 'Office', 'Paper', 40, 3, 8);

Q1. Assign row numbers based on highest sales.
SELECT *, ROW_NUMBER() OVER(ORDER BY sales DESC) AS rn 
FROM sales_data;

Q2. Rank categories by total sales.
SELECT category, SUM(sales) AS total_sales,
RANK() OVER(ORDER BY SUM(sales) DESC) AS category_rank
FROM sales_data
GROUP BY category;

Q3. Dense rank regions by total profit.
SELECT region, SUM(profit) AS total_profit,
DENSE_RANK() OVER(ORDER BY SUM(profit) DESC) AS profit_rank
FROM sales_data
GROUP BY region;

Q4. Compare sales with previous day‚Äôs sales.
SELECT id, order_date, sales,
LAG(sales,1) OVER(ORDER BY order_date) AS previous_sales
FROM sales_data;

Q5. Get sales 2 days after each order (LEAD).
SELECT id, order_date, sales,
LEAD(sales,2) OVER(ORDER BY order_date) AS next_2_sales
FROM sales_data;

Q6. Difference between current and previous sale.
SELECT id, sales,
LAG(sales) OVER(ORDER BY order_date) AS prev,
sales - LAG(sales) OVER(ORDER BY order_date) AS diff
FROM sales_data;

Q7. Running total sales (cumulative).
SELECT id, order_date, sales,
SUM(sales) OVER(ORDER BY order_date) AS running_sales
FROM sales_data;

Q8. Running average sales.
SELECT id, order_date, sales,
AVG(sales) OVER(ORDER BY order_date) AS running_avg
FROM sales_data;

Q9. For each region ‚Üí running total sales.
SELECT region, order_date, sales,
SUM(sales) OVER(PARTITION BY region ORDER BY order_date) AS region_running_sales
FROM sales_data;

Q10. Moving average of last 3 sales.
SELECT order_date, sales,
AVG(sales) OVER(
    ORDER BY order_date
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
) AS moving_avg_3
FROM sales_data;

Q11. Sum of next 2 sales.
SELECT order_date, sales,
SUM(sales) OVER(
    ORDER BY order_date
    ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING
) AS sum_next_2
FROM sales_data;


Q12. Divide all sales into 4 quartiles.
SELECT id, sales,
NTILE(4) OVER(ORDER BY sales DESC) AS sales_quartile
FROM sales_data;

Q13. Split products into top 3 performance buckets.
SELECT id, profit,
NTILE(3) OVER(ORDER BY profit DESC) AS profit_group
FROM sales_data;

Q14. Get each category's highest 2 sales.
SELECT *
FROM (
    SELECT *,
    ROW_NUMBER() OVER(PARTITION BY category ORDER BY sales DESC) AS rn
    FROM sales_data
) t
WHERE rn <= 2;

Q15. Find % change from previous sale.
SELECT id, sales,
LAG(sales) OVER(ORDER BY order_date) AS prev_sale,
((sales - LAG(sales) OVER(ORDER BY order_date)) 
        / LAG(sales) OVER(ORDER BY order_date)) * 100 AS pct_change
FROM sales_data;

Q16. Find best-selling sub_category per region.
SELECT *
FROM (
    SELECT region, sub_category, SUM(sales) AS total_sales,
    ROW_NUMBER() OVER(PARTITION BY region ORDER BY SUM(sales) DESC) AS rn
    FROM sales_data
    GROUP BY region, sub_category
) t
WHERE rn = 1;


